# [Flux](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html)
![Flow](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/doc-files/marbles/flux.svg)
A Reactive Streams Publisher with rx operators that emits 0 to N elements, and then completes (successfully or with an error).

## Static Methods with different parameters
| Method | Description|
|--------|------------|
|static <T,V> Flux<V> 	combineLatest(Function<Object[],V> combinator, int prefetch, Publisher<? extends T>... sources)|Build a Flux whose data are generated by the combination of the most recently published value from each of the Publisher sources.|
|static <T> Flux<T> 	concat(Iterable<? extends Publisher<? extends T>> sources) |Concatenate all sources provided in an Iterable, forwarding elements emitted by the sources downstream.|
|static <T> Flux<T> 	concatDelayError(Publisher<? extends Publisher<? extends T>> sources)|Concatenate all sources emitted as an onNext signal from a parent Publisher, forwarding elements emitted by the sources downstream.|
|static <T> Flux<T> 	create(Consumer<? super FluxSink<T>> emitter)|Programmatically create a Flux with the capability of emitting multiple elements in a synchronous or asynchronous manner through the FluxSink API.|
|static <T> Flux<T> 	defer(Supplier<? extends Publisher<T>> supplier)|Lazily supply a Publisher every time a Subscription is made on the resulting Flux, so the actual source instantiation is deferred until each subscribe and the Supplier can create a subscriber-specific instance.|
|static <T> Flux<T> 	empty()|Create a Flux that completes without emitting any item.|
|static <T> Flux<T> 	error(Supplier<? extends Throwable> errorSupplier)|Create a Flux that terminates with an error immediately after being subscribed to.|
|static <I> Flux<I> 	firstWithSignal(Iterable<? extends Publisher<? extends I>> sources)|Pick the first Publisher to emit any signal (onNext/onError/onComplete) and replay all signals from that Publisher, effectively behaving like the fastest of these competing sources.|
|static <T> Flux<T> 	from(Publisher<? extends T> source)|Decorate the specified Publisher with the Flux API.|
|static <T,S> Flux<T> 	generate(Callable<S> stateSupplier, BiFunction<S,SynchronousSink<T>,S> generator)|Programmatically create a Flux by generating signals one-by-one via a consumer callback and some state.|
|static Flux<Long> 	interval(Duration period)|Create a Flux that emits long values starting with 0 and incrementing at specified time intervals on the global timer.|
|static <T> Flux<T> 	just(T... data)|Create a Flux that emits the provided elements and then completes.|
|static <I> Flux<I> 	merge/mergeComparing/mergeSequential(int prefetch, Publisher<? extends I>... sources)|Merge data from Publisher sequences contained in an array / vararg into an interleaved merged sequence.|
|static <T> Flux<T> 	push(Consumer<? super FluxSink<T>> emitter)|Programmatically create a Flux with the capability of emitting multiple elements from a single-threaded producer through the FluxSink API.|
|static <T> Flux<T> 	switchOnNext(Publisher<? extends Publisher<? extends T>> mergedPublishers)|Creates a Flux that mirrors the most recently emitted Publisher, forwarding its data until a new Publisher comes in the source.|
|static <T,D> Flux<T> 	using/usingWhen(Callable<? extends D> resourceSupplier, Function<? super D,? extends Publisher<? extends T>> sourceSupplier, Consumer<? super D> resourceCleanup)|Uses a resource, generated by a supplier for each individual Subscriber, while streaming the values from a Publisher derived from the same resource and makes sure the resource is released if the sequence terminates or the Subscriber cancels.|
|static <I,O> Flux<O> 	zip(Function<? super Object[],? extends O> combinator, int prefetch, Publisher<? extends I>... sources)|Zip multiple sources together, that is to say wait for all the sources to emit one element and combine these elements once into an output value (constructed by the provided combinator).|

## Instance Method
| Method | Description|
|--------|------------|
|Mono<Boolean> 	all/any(Predicate<? super T> predicate)|Emit a single boolean true if all values of this sequence match the Predicate.|
|T 	blockFirst/Last()|Subscribe to this Flux and block indefinitely until the upstream signals its first value or completes.|
|Flux<List<T>> 	buffer/Timeout/When/Until()|Collect all incoming values into a single List buffer that will be emitted by the returned Flux once this Flux completes.|
|Flux<T> 	cache()|Turn this Flux into a hot source and cache last emitted signals for further Subscriber.|
|<E> Flux<E> 	cast(Class<E> clazz)|Cast the current Flux produced type into a target produced type.|
|Flux<T> 	checkpoint()|Activate traceback (full assembly tracing) for this particular Flux, in case of an error upstream of the checkpoint.|
|<R,A> Mono<R> 	collect/??(Collector<? super T,A,? extends R> collector)|Collect all elements emitted by this Flux into a container, by applying a Java 8 Stream API Collector The collected result will be emitted when this sequence completes, emitting the empty container if the sequence was empty.|
|<V> Flux<V> 	concatMap/??(Function<? super T,? extends Publisher<? extends V>> mapper)|Transform the elements emitted by this Flux asynchronously into Publishers, then flatten these inner publishers into a single Flux, sequentially and preserving order using concatenation.|
|Flux<T> 	delayElements(Duration delay)|Delay each of this Flux elements (Subscriber.onNext(T) signals) by a given Duration.|
|Flux<T> 	distinct()|For each Subscriber, track elements from this Flux that have been seen and filter out duplicates.|
|Flux<T> 	doAfterTerminate(Runnable afterTerminate)|Add behavior (side-effect) triggered after the Flux terminates, either by completing downstream successfully or with an error.|
|Flux<T> 	expand(Function<? super T,? extends Publisher<? extends T>> expander)|Recursively expand elements into a graph and emit all the resulting element using a breadth-first traversal strategy.|
|Flux<T> 	filter(Predicate<? super T> p)|Evaluate each source value against the given Predicate.|
|<R> Flux<R> 	flatMap(Function<? super T,? extends Publisher<? extends R>> mapper)|Transform the elements emitted by this Flux asynchronously into Publishers, then flatten these inner publishers into a single Flux through merging, which allow them to interleave.|
|<K> Flux<GroupedFlux<K,T>> 	groupBy(Function<? super T,? extends K> keyMapper)|Divide this sequence into dynamically created Flux (or groups) for each unique key, as produced by the provided keyMapper Function.|
|Disposable 	subscribe()|Subscribe to this Flux and request unbounded demand.|







